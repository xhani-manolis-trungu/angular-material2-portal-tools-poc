{"ast":null,"code":"/**\n * @license Angular v19.2.4\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\n/**\n * The default equality function used for `signal` and `computed`, which uses referential equality.\n */\nfunction defaultEquals(a, b) {\n  return Object.is(a, b);\n}\n\n/**\n * The currently active consumer `ReactiveNode`, if running code in a reactive context.\n *\n * Change this via `setActiveConsumer`.\n */\nlet activeConsumer = null;\nlet inNotificationPhase = false;\n/**\n * Global epoch counter. Incremented whenever a source signal is set.\n */\nlet epoch = 1;\n/**\n * Symbol used to tell `Signal`s apart from other functions.\n *\n * This can be used to auto-unwrap signals in various cases, or to auto-wrap non-signal values.\n */\nconst SIGNAL = /* @__PURE__ */Symbol('SIGNAL');\nfunction setActiveConsumer(consumer) {\n  const prev = activeConsumer;\n  activeConsumer = consumer;\n  return prev;\n}\nfunction getActiveConsumer() {\n  return activeConsumer;\n}\nfunction isInNotificationPhase() {\n  return inNotificationPhase;\n}\nfunction isReactive(value) {\n  return value[SIGNAL] !== undefined;\n}\nconst REACTIVE_NODE = {\n  version: 0,\n  lastCleanEpoch: 0,\n  dirty: false,\n  producerNode: undefined,\n  producerLastReadVersion: undefined,\n  producerIndexOfThis: undefined,\n  nextProducerIndex: 0,\n  liveConsumerNode: undefined,\n  liveConsumerIndexOfThis: undefined,\n  consumerAllowSignalWrites: false,\n  consumerIsAlwaysLive: false,\n  kind: 'unknown',\n  producerMustRecompute: () => false,\n  producerRecomputeValue: () => {},\n  consumerMarkedDirty: () => {},\n  consumerOnSignalRead: () => {}\n};\n/**\n * Called by implementations when a producer's signal is read.\n */\nfunction producerAccessed(node) {\n  if (inNotificationPhase) {\n    throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? `Assertion error: signal read during notification phase` : '');\n  }\n  if (activeConsumer === null) {\n    // Accessed outside of a reactive context, so nothing to record.\n    return;\n  }\n  activeConsumer.consumerOnSignalRead(node);\n  // This producer is the `idx`th dependency of `activeConsumer`.\n  const idx = activeConsumer.nextProducerIndex++;\n  assertConsumerNode(activeConsumer);\n  if (idx < activeConsumer.producerNode.length && activeConsumer.producerNode[idx] !== node) {\n    // There's been a change in producers since the last execution of `activeConsumer`.\n    // `activeConsumer.producerNode[idx]` holds a stale dependency which will be be removed and\n    // replaced with `this`.\n    //\n    // If `activeConsumer` isn't live, then this is a no-op, since we can replace the producer in\n    // `activeConsumer.producerNode` directly. However, if `activeConsumer` is live, then we need\n    // to remove it from the stale producer's `liveConsumer`s.\n    if (consumerIsLive(activeConsumer)) {\n      const staleProducer = activeConsumer.producerNode[idx];\n      producerRemoveLiveConsumerAtIndex(staleProducer, activeConsumer.producerIndexOfThis[idx]);\n      // At this point, the only record of `staleProducer` is the reference at\n      // `activeConsumer.producerNode[idx]` which will be overwritten below.\n    }\n  }\n  if (activeConsumer.producerNode[idx] !== node) {\n    // We're a new dependency of the consumer (at `idx`).\n    activeConsumer.producerNode[idx] = node;\n    // If the active consumer is live, then add it as a live consumer. If not, then use 0 as a\n    // placeholder value.\n    activeConsumer.producerIndexOfThis[idx] = consumerIsLive(activeConsumer) ? producerAddLiveConsumer(node, activeConsumer, idx) : 0;\n  }\n  activeConsumer.producerLastReadVersion[idx] = node.version;\n}\n/**\n * Increment the global epoch counter.\n *\n * Called by source producers (that is, not computeds) whenever their values change.\n */\nfunction producerIncrementEpoch() {\n  epoch++;\n}\n/**\n * Ensure this producer's `version` is up-to-date.\n */\nfunction producerUpdateValueVersion(node) {\n  if (consumerIsLive(node) && !node.dirty) {\n    // A live consumer will be marked dirty by producers, so a clean state means that its version\n    // is guaranteed to be up-to-date.\n    return;\n  }\n  if (!node.dirty && node.lastCleanEpoch === epoch) {\n    // Even non-live consumers can skip polling if they previously found themselves to be clean at\n    // the current epoch, since their dependencies could not possibly have changed (such a change\n    // would've increased the epoch).\n    return;\n  }\n  if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {\n    // None of our producers report a change since the last time they were read, so no\n    // recomputation of our value is necessary, and we can consider ourselves clean.\n    producerMarkClean(node);\n    return;\n  }\n  node.producerRecomputeValue(node);\n  // After recomputing the value, we're no longer dirty.\n  producerMarkClean(node);\n}\n/**\n * Propagate a dirty notification to live consumers of this producer.\n */\nfunction producerNotifyConsumers(node) {\n  if (node.liveConsumerNode === undefined) {\n    return;\n  }\n  // Prevent signal reads when we're updating the graph\n  const prev = inNotificationPhase;\n  inNotificationPhase = true;\n  try {\n    for (const consumer of node.liveConsumerNode) {\n      if (!consumer.dirty) {\n        consumerMarkDirty(consumer);\n      }\n    }\n  } finally {\n    inNotificationPhase = prev;\n  }\n}\n/**\n * Whether this `ReactiveNode` in its producer capacity is currently allowed to initiate updates,\n * based on the current consumer context.\n */\nfunction producerUpdatesAllowed() {\n  return activeConsumer?.consumerAllowSignalWrites !== false;\n}\nfunction consumerMarkDirty(node) {\n  node.dirty = true;\n  producerNotifyConsumers(node);\n  node.consumerMarkedDirty?.(node);\n}\nfunction producerMarkClean(node) {\n  node.dirty = false;\n  node.lastCleanEpoch = epoch;\n}\n/**\n * Prepare this consumer to run a computation in its reactive context.\n *\n * Must be called by subclasses which represent reactive computations, before those computations\n * begin.\n */\nfunction consumerBeforeComputation(node) {\n  node && (node.nextProducerIndex = 0);\n  return setActiveConsumer(node);\n}\n/**\n * Finalize this consumer's state after a reactive computation has run.\n *\n * Must be called by subclasses which represent reactive computations, after those computations\n * have finished.\n */\nfunction consumerAfterComputation(node, prevConsumer) {\n  setActiveConsumer(prevConsumer);\n  if (!node || node.producerNode === undefined || node.producerIndexOfThis === undefined || node.producerLastReadVersion === undefined) {\n    return;\n  }\n  if (consumerIsLive(node)) {\n    // For live consumers, we need to remove the producer -> consumer edge for any stale producers\n    // which weren't dependencies after the recomputation.\n    for (let i = node.nextProducerIndex; i < node.producerNode.length; i++) {\n      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n    }\n  }\n  // Truncate the producer tracking arrays.\n  // Perf note: this is essentially truncating the length to `node.nextProducerIndex`, but\n  // benchmarking has shown that individual pop operations are faster.\n  while (node.producerNode.length > node.nextProducerIndex) {\n    node.producerNode.pop();\n    node.producerLastReadVersion.pop();\n    node.producerIndexOfThis.pop();\n  }\n}\n/**\n * Determine whether this consumer has any dependencies which have changed since the last time\n * they were read.\n */\nfunction consumerPollProducersForChange(node) {\n  assertConsumerNode(node);\n  // Poll producers for change.\n  for (let i = 0; i < node.producerNode.length; i++) {\n    const producer = node.producerNode[i];\n    const seenVersion = node.producerLastReadVersion[i];\n    // First check the versions. A mismatch means that the producer's value is known to have\n    // changed since the last time we read it.\n    if (seenVersion !== producer.version) {\n      return true;\n    }\n    // The producer's version is the same as the last time we read it, but it might itself be\n    // stale. Force the producer to recompute its version (calculating a new value if necessary).\n    producerUpdateValueVersion(producer);\n    // Now when we do this check, `producer.version` is guaranteed to be up to date, so if the\n    // versions still match then it has not changed since the last time we read it.\n    if (seenVersion !== producer.version) {\n      return true;\n    }\n  }\n  return false;\n}\n/**\n * Disconnect this consumer from the graph.\n */\nfunction consumerDestroy(node) {\n  assertConsumerNode(node);\n  if (consumerIsLive(node)) {\n    // Drop all connections from the graph to this node.\n    for (let i = 0; i < node.producerNode.length; i++) {\n      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n    }\n  }\n  // Truncate all the arrays to drop all connection from this node to the graph.\n  node.producerNode.length = node.producerLastReadVersion.length = node.producerIndexOfThis.length = 0;\n  if (node.liveConsumerNode) {\n    node.liveConsumerNode.length = node.liveConsumerIndexOfThis.length = 0;\n  }\n}\n/**\n * Add `consumer` as a live consumer of this node.\n *\n * Note that this operation is potentially transitive. If this node becomes live, then it becomes\n * a live consumer of all of its current producers.\n */\nfunction producerAddLiveConsumer(node, consumer, indexOfThis) {\n  assertProducerNode(node);\n  if (node.liveConsumerNode.length === 0 && isConsumerNode(node)) {\n    // When going from 0 to 1 live consumers, we become a live consumer to our producers.\n    for (let i = 0; i < node.producerNode.length; i++) {\n      node.producerIndexOfThis[i] = producerAddLiveConsumer(node.producerNode[i], node, i);\n    }\n  }\n  node.liveConsumerIndexOfThis.push(indexOfThis);\n  return node.liveConsumerNode.push(consumer) - 1;\n}\n/**\n * Remove the live consumer at `idx`.\n */\nfunction producerRemoveLiveConsumerAtIndex(node, idx) {\n  assertProducerNode(node);\n  if (typeof ngDevMode !== 'undefined' && ngDevMode && idx >= node.liveConsumerNode.length) {\n    throw new Error(`Assertion error: active consumer index ${idx} is out of bounds of ${node.liveConsumerNode.length} consumers)`);\n  }\n  if (node.liveConsumerNode.length === 1 && isConsumerNode(node)) {\n    // When removing the last live consumer, we will no longer be live. We need to remove\n    // ourselves from our producers' tracking (which may cause consumer-producers to lose\n    // liveness as well).\n    for (let i = 0; i < node.producerNode.length; i++) {\n      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n    }\n  }\n  // Move the last value of `liveConsumers` into `idx`. Note that if there's only a single\n  // live consumer, this is a no-op.\n  const lastIdx = node.liveConsumerNode.length - 1;\n  node.liveConsumerNode[idx] = node.liveConsumerNode[lastIdx];\n  node.liveConsumerIndexOfThis[idx] = node.liveConsumerIndexOfThis[lastIdx];\n  // Truncate the array.\n  node.liveConsumerNode.length--;\n  node.liveConsumerIndexOfThis.length--;\n  // If the index is still valid, then we need to fix the index pointer from the producer to this\n  // consumer, and update it from `lastIdx` to `idx` (accounting for the move above).\n  if (idx < node.liveConsumerNode.length) {\n    const idxProducer = node.liveConsumerIndexOfThis[idx];\n    const consumer = node.liveConsumerNode[idx];\n    assertConsumerNode(consumer);\n    consumer.producerIndexOfThis[idxProducer] = idx;\n  }\n}\nfunction consumerIsLive(node) {\n  return node.consumerIsAlwaysLive || (node?.liveConsumerNode?.length ?? 0) > 0;\n}\nfunction assertConsumerNode(node) {\n  node.producerNode ??= [];\n  node.producerIndexOfThis ??= [];\n  node.producerLastReadVersion ??= [];\n}\nfunction assertProducerNode(node) {\n  node.liveConsumerNode ??= [];\n  node.liveConsumerIndexOfThis ??= [];\n}\nfunction isConsumerNode(node) {\n  return node.producerNode !== undefined;\n}\n\n/**\n * Create a computed signal which derives a reactive value from an expression.\n */\nfunction createComputed(computation, equal) {\n  const node = Object.create(COMPUTED_NODE);\n  node.computation = computation;\n  if (equal !== undefined) {\n    node.equal = equal;\n  }\n  const computed = () => {\n    // Check if the value needs updating before returning it.\n    producerUpdateValueVersion(node);\n    // Record that someone looked at this signal.\n    producerAccessed(node);\n    if (node.value === ERRORED) {\n      throw node.error;\n    }\n    return node.value;\n  };\n  computed[SIGNAL] = node;\n  return computed;\n}\n/**\n * A dedicated symbol used before a computed value has been calculated for the first time.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst UNSET = /* @__PURE__ */Symbol('UNSET');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * is in progress. Used to detect cycles in computation chains.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst COMPUTING = /* @__PURE__ */Symbol('COMPUTING');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * failed. The thrown error is cached until the computation gets dirty again.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst ERRORED = /* @__PURE__ */Symbol('ERRORED');\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst COMPUTED_NODE = /* @__PURE__ */(() => {\n  return {\n    ...REACTIVE_NODE,\n    value: UNSET,\n    dirty: true,\n    error: null,\n    equal: defaultEquals,\n    kind: 'computed',\n    producerMustRecompute(node) {\n      // Force a recomputation if there's no current value, or if the current value is in the\n      // process of being calculated (which should throw an error).\n      return node.value === UNSET || node.value === COMPUTING;\n    },\n    producerRecomputeValue(node) {\n      if (node.value === COMPUTING) {\n        // Our computation somehow led to a cyclic read of itself.\n        throw new Error('Detected cycle in computations.');\n      }\n      const oldValue = node.value;\n      node.value = COMPUTING;\n      const prevConsumer = consumerBeforeComputation(node);\n      let newValue;\n      let wasEqual = false;\n      try {\n        newValue = node.computation();\n        // We want to mark this node as errored if calling `equal` throws; however, we don't want\n        // to track any reactive reads inside `equal`.\n        setActiveConsumer(null);\n        wasEqual = oldValue !== UNSET && oldValue !== ERRORED && newValue !== ERRORED && node.equal(oldValue, newValue);\n      } catch (err) {\n        newValue = ERRORED;\n        node.error = err;\n      } finally {\n        consumerAfterComputation(node, prevConsumer);\n      }\n      if (wasEqual) {\n        // No change to `valueVersion` - old and new values are\n        // semantically equivalent.\n        node.value = oldValue;\n        return;\n      }\n      node.value = newValue;\n      node.version++;\n    }\n  };\n})();\nfunction defaultThrowError() {\n  throw new Error();\n}\nlet throwInvalidWriteToSignalErrorFn = defaultThrowError;\nfunction throwInvalidWriteToSignalError(node) {\n  throwInvalidWriteToSignalErrorFn(node);\n}\nfunction setThrowInvalidWriteToSignalError(fn) {\n  throwInvalidWriteToSignalErrorFn = fn;\n}\n\n/**\n * If set, called after `WritableSignal`s are updated.\n *\n * This hook can be used to achieve various effects, such as running effects synchronously as part\n * of setting a signal.\n */\nlet postSignalSetFn = null;\n/**\n * Create a `Signal` that can be set or updated directly.\n */\nfunction createSignal(initialValue, equal) {\n  const node = Object.create(SIGNAL_NODE);\n  node.value = initialValue;\n  if (equal !== undefined) {\n    node.equal = equal;\n  }\n  const getter = () => {\n    producerAccessed(node);\n    return node.value;\n  };\n  getter[SIGNAL] = node;\n  return getter;\n}\nfunction setPostSignalSetFn(fn) {\n  const prev = postSignalSetFn;\n  postSignalSetFn = fn;\n  return prev;\n}\nfunction signalSetFn(node, newValue) {\n  if (!producerUpdatesAllowed()) {\n    throwInvalidWriteToSignalError(node);\n  }\n  if (!node.equal(node.value, newValue)) {\n    node.value = newValue;\n    signalValueChanged(node);\n  }\n}\nfunction signalUpdateFn(node, updater) {\n  if (!producerUpdatesAllowed()) {\n    throwInvalidWriteToSignalError(node);\n  }\n  signalSetFn(node, updater(node.value));\n}\nfunction runPostSignalSetFn() {\n  postSignalSetFn?.();\n}\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst SIGNAL_NODE = /* @__PURE__ */(() => {\n  return {\n    ...REACTIVE_NODE,\n    equal: defaultEquals,\n    value: undefined,\n    kind: 'signal'\n  };\n})();\nfunction signalValueChanged(node) {\n  node.version++;\n  producerIncrementEpoch();\n  producerNotifyConsumers(node);\n  postSignalSetFn?.();\n}\nfunction createLinkedSignal(sourceFn, computationFn, equalityFn) {\n  const node = Object.create(LINKED_SIGNAL_NODE);\n  node.source = sourceFn;\n  node.computation = computationFn;\n  if (equalityFn != undefined) {\n    node.equal = equalityFn;\n  }\n  const linkedSignalGetter = () => {\n    // Check if the value needs updating before returning it.\n    producerUpdateValueVersion(node);\n    // Record that someone looked at this signal.\n    producerAccessed(node);\n    if (node.value === ERRORED) {\n      throw node.error;\n    }\n    return node.value;\n  };\n  const getter = linkedSignalGetter;\n  getter[SIGNAL] = node;\n  return getter;\n}\nfunction linkedSignalSetFn(node, newValue) {\n  producerUpdateValueVersion(node);\n  signalSetFn(node, newValue);\n  producerMarkClean(node);\n}\nfunction linkedSignalUpdateFn(node, updater) {\n  producerUpdateValueVersion(node);\n  signalUpdateFn(node, updater);\n  producerMarkClean(node);\n}\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `LINKED_SIGNAL_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst LINKED_SIGNAL_NODE = /* @__PURE__ */(() => {\n  return {\n    ...REACTIVE_NODE,\n    value: UNSET,\n    dirty: true,\n    error: null,\n    equal: defaultEquals,\n    kind: 'linkedSignal',\n    producerMustRecompute(node) {\n      // Force a recomputation if there's no current value, or if the current value is in the\n      // process of being calculated (which should throw an error).\n      return node.value === UNSET || node.value === COMPUTING;\n    },\n    producerRecomputeValue(node) {\n      if (node.value === COMPUTING) {\n        // Our computation somehow led to a cyclic read of itself.\n        throw new Error('Detected cycle in computations.');\n      }\n      const oldValue = node.value;\n      node.value = COMPUTING;\n      const prevConsumer = consumerBeforeComputation(node);\n      let newValue;\n      try {\n        const newSourceValue = node.source();\n        const prev = oldValue === UNSET || oldValue === ERRORED ? undefined : {\n          source: node.sourceValue,\n          value: oldValue\n        };\n        newValue = node.computation(newSourceValue, prev);\n        node.sourceValue = newSourceValue;\n      } catch (err) {\n        newValue = ERRORED;\n        node.error = err;\n      } finally {\n        consumerAfterComputation(node, prevConsumer);\n      }\n      if (oldValue !== UNSET && newValue !== ERRORED && node.equal(oldValue, newValue)) {\n        // No change to `valueVersion` - old and new values are\n        // semantically equivalent.\n        node.value = oldValue;\n        return;\n      }\n      node.value = newValue;\n      node.version++;\n    }\n  };\n})();\nfunction setAlternateWeakRefImpl(impl) {\n  // TODO: remove this function\n}\n\n/**\n * Execute an arbitrary function in a non-reactive (non-tracking) context. The executed function\n * can, optionally, return a value.\n */\nfunction untracked(nonReactiveReadsFn) {\n  const prevConsumer = setActiveConsumer(null);\n  // We are not trying to catch any particular errors here, just making sure that the consumers\n  // stack is restored in case of errors.\n  try {\n    return nonReactiveReadsFn();\n  } finally {\n    setActiveConsumer(prevConsumer);\n  }\n}\nexport { signalUpdateFn as A, setAlternateWeakRefImpl as B, untracked as C, REACTIVE_NODE as R, SIGNAL as S, consumerDestroy as a, consumerPollProducersForChange as b, consumerMarkDirty as c, consumerBeforeComputation as d, consumerAfterComputation as e, createComputed as f, createLinkedSignal as g, linkedSignalUpdateFn as h, isInNotificationPhase as i, defaultEquals as j, getActiveConsumer as k, linkedSignalSetFn as l, isReactive as m, producerIncrementEpoch as n, producerMarkClean as o, producerAccessed as p, producerNotifyConsumers as q, producerUpdateValueVersion as r, setThrowInvalidWriteToSignalError as s, producerUpdatesAllowed as t, setActiveConsumer as u, SIGNAL_NODE as v, createSignal as w, runPostSignalSetFn as x, setPostSignalSetFn as y, signalSetFn as z };","map":{"version":3,"names":["defaultEquals","a","b","Object","is","activeConsumer","inNotificationPhase","epoch","SIGNAL","Symbol","setActiveConsumer","consumer","prev","getActiveConsumer","isInNotificationPhase","isReactive","value","undefined","REACTIVE_NODE","version","lastCleanEpoch","dirty","producerNode","producerLastReadVersion","producerIndexOfThis","nextProducerIndex","liveConsumerNode","liveConsumerIndexOfThis","consumerAllowSignalWrites","consumerIsAlwaysLive","kind","producerMustRecompute","producerRecomputeValue","consumerMarkedDirty","consumerOnSignalRead","producerAccessed","node","Error","ngDevMode","idx","assertConsumerNode","length","consumerIsLive","staleProducer","producerRemoveLiveConsumerAtIndex","producerAddLiveConsumer","producerIncrementEpoch","producerUpdateValueVersion","consumerPollProducersForChange","producerMarkClean","producerNotifyConsumers","consumerMarkDirty","producerUpdatesAllowed","consumerBeforeComputation","consumerAfterComputation","prevConsumer","i","pop","producer","seenVersion","consumerDestroy","indexOfThis","assertProducerNode","isConsumerNode","push","lastIdx","idxProducer","createComputed","computation","equal","create","COMPUTED_NODE","computed","ERRORED","error","UNSET","COMPUTING","oldValue","newValue","wasEqual","err","defaultThrowError","throwInvalidWriteToSignalErrorFn","throwInvalidWriteToSignalError","setThrowInvalidWriteToSignalError","fn","postSignalSetFn","createSignal","initialValue","SIGNAL_NODE","getter","setPostSignalSetFn","signalSetFn","signalValueChanged","signalUpdateFn","updater","runPostSignalSetFn","createLinkedSignal","sourceFn","computationFn","equalityFn","LINKED_SIGNAL_NODE","source","linkedSignalGetter","linkedSignalSetFn","linkedSignalUpdateFn","newSourceValue","sourceValue","setAlternateWeakRefImpl","impl","untracked","nonReactiveReadsFn","A","B","C","R","S","c","d","e","f","g","h","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"],"sources":["/home/xhani-manolis-trungu/angular-material2-portal-tools-poc/node_modules/@angular/core/fesm2022/untracked-CS7WUAzb.mjs"],"sourcesContent":["/**\n * @license Angular v19.2.4\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\n/**\n * The default equality function used for `signal` and `computed`, which uses referential equality.\n */\nfunction defaultEquals(a, b) {\n    return Object.is(a, b);\n}\n\n/**\n * The currently active consumer `ReactiveNode`, if running code in a reactive context.\n *\n * Change this via `setActiveConsumer`.\n */\nlet activeConsumer = null;\nlet inNotificationPhase = false;\n/**\n * Global epoch counter. Incremented whenever a source signal is set.\n */\nlet epoch = 1;\n/**\n * Symbol used to tell `Signal`s apart from other functions.\n *\n * This can be used to auto-unwrap signals in various cases, or to auto-wrap non-signal values.\n */\nconst SIGNAL = /* @__PURE__ */ Symbol('SIGNAL');\nfunction setActiveConsumer(consumer) {\n    const prev = activeConsumer;\n    activeConsumer = consumer;\n    return prev;\n}\nfunction getActiveConsumer() {\n    return activeConsumer;\n}\nfunction isInNotificationPhase() {\n    return inNotificationPhase;\n}\nfunction isReactive(value) {\n    return value[SIGNAL] !== undefined;\n}\nconst REACTIVE_NODE = {\n    version: 0,\n    lastCleanEpoch: 0,\n    dirty: false,\n    producerNode: undefined,\n    producerLastReadVersion: undefined,\n    producerIndexOfThis: undefined,\n    nextProducerIndex: 0,\n    liveConsumerNode: undefined,\n    liveConsumerIndexOfThis: undefined,\n    consumerAllowSignalWrites: false,\n    consumerIsAlwaysLive: false,\n    kind: 'unknown',\n    producerMustRecompute: () => false,\n    producerRecomputeValue: () => { },\n    consumerMarkedDirty: () => { },\n    consumerOnSignalRead: () => { },\n};\n/**\n * Called by implementations when a producer's signal is read.\n */\nfunction producerAccessed(node) {\n    if (inNotificationPhase) {\n        throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode\n            ? `Assertion error: signal read during notification phase`\n            : '');\n    }\n    if (activeConsumer === null) {\n        // Accessed outside of a reactive context, so nothing to record.\n        return;\n    }\n    activeConsumer.consumerOnSignalRead(node);\n    // This producer is the `idx`th dependency of `activeConsumer`.\n    const idx = activeConsumer.nextProducerIndex++;\n    assertConsumerNode(activeConsumer);\n    if (idx < activeConsumer.producerNode.length && activeConsumer.producerNode[idx] !== node) {\n        // There's been a change in producers since the last execution of `activeConsumer`.\n        // `activeConsumer.producerNode[idx]` holds a stale dependency which will be be removed and\n        // replaced with `this`.\n        //\n        // If `activeConsumer` isn't live, then this is a no-op, since we can replace the producer in\n        // `activeConsumer.producerNode` directly. However, if `activeConsumer` is live, then we need\n        // to remove it from the stale producer's `liveConsumer`s.\n        if (consumerIsLive(activeConsumer)) {\n            const staleProducer = activeConsumer.producerNode[idx];\n            producerRemoveLiveConsumerAtIndex(staleProducer, activeConsumer.producerIndexOfThis[idx]);\n            // At this point, the only record of `staleProducer` is the reference at\n            // `activeConsumer.producerNode[idx]` which will be overwritten below.\n        }\n    }\n    if (activeConsumer.producerNode[idx] !== node) {\n        // We're a new dependency of the consumer (at `idx`).\n        activeConsumer.producerNode[idx] = node;\n        // If the active consumer is live, then add it as a live consumer. If not, then use 0 as a\n        // placeholder value.\n        activeConsumer.producerIndexOfThis[idx] = consumerIsLive(activeConsumer)\n            ? producerAddLiveConsumer(node, activeConsumer, idx)\n            : 0;\n    }\n    activeConsumer.producerLastReadVersion[idx] = node.version;\n}\n/**\n * Increment the global epoch counter.\n *\n * Called by source producers (that is, not computeds) whenever their values change.\n */\nfunction producerIncrementEpoch() {\n    epoch++;\n}\n/**\n * Ensure this producer's `version` is up-to-date.\n */\nfunction producerUpdateValueVersion(node) {\n    if (consumerIsLive(node) && !node.dirty) {\n        // A live consumer will be marked dirty by producers, so a clean state means that its version\n        // is guaranteed to be up-to-date.\n        return;\n    }\n    if (!node.dirty && node.lastCleanEpoch === epoch) {\n        // Even non-live consumers can skip polling if they previously found themselves to be clean at\n        // the current epoch, since their dependencies could not possibly have changed (such a change\n        // would've increased the epoch).\n        return;\n    }\n    if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {\n        // None of our producers report a change since the last time they were read, so no\n        // recomputation of our value is necessary, and we can consider ourselves clean.\n        producerMarkClean(node);\n        return;\n    }\n    node.producerRecomputeValue(node);\n    // After recomputing the value, we're no longer dirty.\n    producerMarkClean(node);\n}\n/**\n * Propagate a dirty notification to live consumers of this producer.\n */\nfunction producerNotifyConsumers(node) {\n    if (node.liveConsumerNode === undefined) {\n        return;\n    }\n    // Prevent signal reads when we're updating the graph\n    const prev = inNotificationPhase;\n    inNotificationPhase = true;\n    try {\n        for (const consumer of node.liveConsumerNode) {\n            if (!consumer.dirty) {\n                consumerMarkDirty(consumer);\n            }\n        }\n    }\n    finally {\n        inNotificationPhase = prev;\n    }\n}\n/**\n * Whether this `ReactiveNode` in its producer capacity is currently allowed to initiate updates,\n * based on the current consumer context.\n */\nfunction producerUpdatesAllowed() {\n    return activeConsumer?.consumerAllowSignalWrites !== false;\n}\nfunction consumerMarkDirty(node) {\n    node.dirty = true;\n    producerNotifyConsumers(node);\n    node.consumerMarkedDirty?.(node);\n}\nfunction producerMarkClean(node) {\n    node.dirty = false;\n    node.lastCleanEpoch = epoch;\n}\n/**\n * Prepare this consumer to run a computation in its reactive context.\n *\n * Must be called by subclasses which represent reactive computations, before those computations\n * begin.\n */\nfunction consumerBeforeComputation(node) {\n    node && (node.nextProducerIndex = 0);\n    return setActiveConsumer(node);\n}\n/**\n * Finalize this consumer's state after a reactive computation has run.\n *\n * Must be called by subclasses which represent reactive computations, after those computations\n * have finished.\n */\nfunction consumerAfterComputation(node, prevConsumer) {\n    setActiveConsumer(prevConsumer);\n    if (!node ||\n        node.producerNode === undefined ||\n        node.producerIndexOfThis === undefined ||\n        node.producerLastReadVersion === undefined) {\n        return;\n    }\n    if (consumerIsLive(node)) {\n        // For live consumers, we need to remove the producer -> consumer edge for any stale producers\n        // which weren't dependencies after the recomputation.\n        for (let i = node.nextProducerIndex; i < node.producerNode.length; i++) {\n            producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n        }\n    }\n    // Truncate the producer tracking arrays.\n    // Perf note: this is essentially truncating the length to `node.nextProducerIndex`, but\n    // benchmarking has shown that individual pop operations are faster.\n    while (node.producerNode.length > node.nextProducerIndex) {\n        node.producerNode.pop();\n        node.producerLastReadVersion.pop();\n        node.producerIndexOfThis.pop();\n    }\n}\n/**\n * Determine whether this consumer has any dependencies which have changed since the last time\n * they were read.\n */\nfunction consumerPollProducersForChange(node) {\n    assertConsumerNode(node);\n    // Poll producers for change.\n    for (let i = 0; i < node.producerNode.length; i++) {\n        const producer = node.producerNode[i];\n        const seenVersion = node.producerLastReadVersion[i];\n        // First check the versions. A mismatch means that the producer's value is known to have\n        // changed since the last time we read it.\n        if (seenVersion !== producer.version) {\n            return true;\n        }\n        // The producer's version is the same as the last time we read it, but it might itself be\n        // stale. Force the producer to recompute its version (calculating a new value if necessary).\n        producerUpdateValueVersion(producer);\n        // Now when we do this check, `producer.version` is guaranteed to be up to date, so if the\n        // versions still match then it has not changed since the last time we read it.\n        if (seenVersion !== producer.version) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Disconnect this consumer from the graph.\n */\nfunction consumerDestroy(node) {\n    assertConsumerNode(node);\n    if (consumerIsLive(node)) {\n        // Drop all connections from the graph to this node.\n        for (let i = 0; i < node.producerNode.length; i++) {\n            producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n        }\n    }\n    // Truncate all the arrays to drop all connection from this node to the graph.\n    node.producerNode.length =\n        node.producerLastReadVersion.length =\n            node.producerIndexOfThis.length =\n                0;\n    if (node.liveConsumerNode) {\n        node.liveConsumerNode.length = node.liveConsumerIndexOfThis.length = 0;\n    }\n}\n/**\n * Add `consumer` as a live consumer of this node.\n *\n * Note that this operation is potentially transitive. If this node becomes live, then it becomes\n * a live consumer of all of its current producers.\n */\nfunction producerAddLiveConsumer(node, consumer, indexOfThis) {\n    assertProducerNode(node);\n    if (node.liveConsumerNode.length === 0 && isConsumerNode(node)) {\n        // When going from 0 to 1 live consumers, we become a live consumer to our producers.\n        for (let i = 0; i < node.producerNode.length; i++) {\n            node.producerIndexOfThis[i] = producerAddLiveConsumer(node.producerNode[i], node, i);\n        }\n    }\n    node.liveConsumerIndexOfThis.push(indexOfThis);\n    return node.liveConsumerNode.push(consumer) - 1;\n}\n/**\n * Remove the live consumer at `idx`.\n */\nfunction producerRemoveLiveConsumerAtIndex(node, idx) {\n    assertProducerNode(node);\n    if (typeof ngDevMode !== 'undefined' && ngDevMode && idx >= node.liveConsumerNode.length) {\n        throw new Error(`Assertion error: active consumer index ${idx} is out of bounds of ${node.liveConsumerNode.length} consumers)`);\n    }\n    if (node.liveConsumerNode.length === 1 && isConsumerNode(node)) {\n        // When removing the last live consumer, we will no longer be live. We need to remove\n        // ourselves from our producers' tracking (which may cause consumer-producers to lose\n        // liveness as well).\n        for (let i = 0; i < node.producerNode.length; i++) {\n            producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n        }\n    }\n    // Move the last value of `liveConsumers` into `idx`. Note that if there's only a single\n    // live consumer, this is a no-op.\n    const lastIdx = node.liveConsumerNode.length - 1;\n    node.liveConsumerNode[idx] = node.liveConsumerNode[lastIdx];\n    node.liveConsumerIndexOfThis[idx] = node.liveConsumerIndexOfThis[lastIdx];\n    // Truncate the array.\n    node.liveConsumerNode.length--;\n    node.liveConsumerIndexOfThis.length--;\n    // If the index is still valid, then we need to fix the index pointer from the producer to this\n    // consumer, and update it from `lastIdx` to `idx` (accounting for the move above).\n    if (idx < node.liveConsumerNode.length) {\n        const idxProducer = node.liveConsumerIndexOfThis[idx];\n        const consumer = node.liveConsumerNode[idx];\n        assertConsumerNode(consumer);\n        consumer.producerIndexOfThis[idxProducer] = idx;\n    }\n}\nfunction consumerIsLive(node) {\n    return node.consumerIsAlwaysLive || (node?.liveConsumerNode?.length ?? 0) > 0;\n}\nfunction assertConsumerNode(node) {\n    node.producerNode ??= [];\n    node.producerIndexOfThis ??= [];\n    node.producerLastReadVersion ??= [];\n}\nfunction assertProducerNode(node) {\n    node.liveConsumerNode ??= [];\n    node.liveConsumerIndexOfThis ??= [];\n}\nfunction isConsumerNode(node) {\n    return node.producerNode !== undefined;\n}\n\n/**\n * Create a computed signal which derives a reactive value from an expression.\n */\nfunction createComputed(computation, equal) {\n    const node = Object.create(COMPUTED_NODE);\n    node.computation = computation;\n    if (equal !== undefined) {\n        node.equal = equal;\n    }\n    const computed = () => {\n        // Check if the value needs updating before returning it.\n        producerUpdateValueVersion(node);\n        // Record that someone looked at this signal.\n        producerAccessed(node);\n        if (node.value === ERRORED) {\n            throw node.error;\n        }\n        return node.value;\n    };\n    computed[SIGNAL] = node;\n    return computed;\n}\n/**\n * A dedicated symbol used before a computed value has been calculated for the first time.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst UNSET = /* @__PURE__ */ Symbol('UNSET');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * is in progress. Used to detect cycles in computation chains.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst COMPUTING = /* @__PURE__ */ Symbol('COMPUTING');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * failed. The thrown error is cached until the computation gets dirty again.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst ERRORED = /* @__PURE__ */ Symbol('ERRORED');\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst COMPUTED_NODE = /* @__PURE__ */ (() => {\n    return {\n        ...REACTIVE_NODE,\n        value: UNSET,\n        dirty: true,\n        error: null,\n        equal: defaultEquals,\n        kind: 'computed',\n        producerMustRecompute(node) {\n            // Force a recomputation if there's no current value, or if the current value is in the\n            // process of being calculated (which should throw an error).\n            return node.value === UNSET || node.value === COMPUTING;\n        },\n        producerRecomputeValue(node) {\n            if (node.value === COMPUTING) {\n                // Our computation somehow led to a cyclic read of itself.\n                throw new Error('Detected cycle in computations.');\n            }\n            const oldValue = node.value;\n            node.value = COMPUTING;\n            const prevConsumer = consumerBeforeComputation(node);\n            let newValue;\n            let wasEqual = false;\n            try {\n                newValue = node.computation();\n                // We want to mark this node as errored if calling `equal` throws; however, we don't want\n                // to track any reactive reads inside `equal`.\n                setActiveConsumer(null);\n                wasEqual =\n                    oldValue !== UNSET &&\n                        oldValue !== ERRORED &&\n                        newValue !== ERRORED &&\n                        node.equal(oldValue, newValue);\n            }\n            catch (err) {\n                newValue = ERRORED;\n                node.error = err;\n            }\n            finally {\n                consumerAfterComputation(node, prevConsumer);\n            }\n            if (wasEqual) {\n                // No change to `valueVersion` - old and new values are\n                // semantically equivalent.\n                node.value = oldValue;\n                return;\n            }\n            node.value = newValue;\n            node.version++;\n        },\n    };\n})();\n\nfunction defaultThrowError() {\n    throw new Error();\n}\nlet throwInvalidWriteToSignalErrorFn = defaultThrowError;\nfunction throwInvalidWriteToSignalError(node) {\n    throwInvalidWriteToSignalErrorFn(node);\n}\nfunction setThrowInvalidWriteToSignalError(fn) {\n    throwInvalidWriteToSignalErrorFn = fn;\n}\n\n/**\n * If set, called after `WritableSignal`s are updated.\n *\n * This hook can be used to achieve various effects, such as running effects synchronously as part\n * of setting a signal.\n */\nlet postSignalSetFn = null;\n/**\n * Create a `Signal` that can be set or updated directly.\n */\nfunction createSignal(initialValue, equal) {\n    const node = Object.create(SIGNAL_NODE);\n    node.value = initialValue;\n    if (equal !== undefined) {\n        node.equal = equal;\n    }\n    const getter = (() => {\n        producerAccessed(node);\n        return node.value;\n    });\n    getter[SIGNAL] = node;\n    return getter;\n}\nfunction setPostSignalSetFn(fn) {\n    const prev = postSignalSetFn;\n    postSignalSetFn = fn;\n    return prev;\n}\nfunction signalSetFn(node, newValue) {\n    if (!producerUpdatesAllowed()) {\n        throwInvalidWriteToSignalError(node);\n    }\n    if (!node.equal(node.value, newValue)) {\n        node.value = newValue;\n        signalValueChanged(node);\n    }\n}\nfunction signalUpdateFn(node, updater) {\n    if (!producerUpdatesAllowed()) {\n        throwInvalidWriteToSignalError(node);\n    }\n    signalSetFn(node, updater(node.value));\n}\nfunction runPostSignalSetFn() {\n    postSignalSetFn?.();\n}\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst SIGNAL_NODE = /* @__PURE__ */ (() => {\n    return {\n        ...REACTIVE_NODE,\n        equal: defaultEquals,\n        value: undefined,\n        kind: 'signal',\n    };\n})();\nfunction signalValueChanged(node) {\n    node.version++;\n    producerIncrementEpoch();\n    producerNotifyConsumers(node);\n    postSignalSetFn?.();\n}\n\nfunction createLinkedSignal(sourceFn, computationFn, equalityFn) {\n    const node = Object.create(LINKED_SIGNAL_NODE);\n    node.source = sourceFn;\n    node.computation = computationFn;\n    if (equalityFn != undefined) {\n        node.equal = equalityFn;\n    }\n    const linkedSignalGetter = () => {\n        // Check if the value needs updating before returning it.\n        producerUpdateValueVersion(node);\n        // Record that someone looked at this signal.\n        producerAccessed(node);\n        if (node.value === ERRORED) {\n            throw node.error;\n        }\n        return node.value;\n    };\n    const getter = linkedSignalGetter;\n    getter[SIGNAL] = node;\n    return getter;\n}\nfunction linkedSignalSetFn(node, newValue) {\n    producerUpdateValueVersion(node);\n    signalSetFn(node, newValue);\n    producerMarkClean(node);\n}\nfunction linkedSignalUpdateFn(node, updater) {\n    producerUpdateValueVersion(node);\n    signalUpdateFn(node, updater);\n    producerMarkClean(node);\n}\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `LINKED_SIGNAL_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst LINKED_SIGNAL_NODE = /* @__PURE__ */ (() => {\n    return {\n        ...REACTIVE_NODE,\n        value: UNSET,\n        dirty: true,\n        error: null,\n        equal: defaultEquals,\n        kind: 'linkedSignal',\n        producerMustRecompute(node) {\n            // Force a recomputation if there's no current value, or if the current value is in the\n            // process of being calculated (which should throw an error).\n            return node.value === UNSET || node.value === COMPUTING;\n        },\n        producerRecomputeValue(node) {\n            if (node.value === COMPUTING) {\n                // Our computation somehow led to a cyclic read of itself.\n                throw new Error('Detected cycle in computations.');\n            }\n            const oldValue = node.value;\n            node.value = COMPUTING;\n            const prevConsumer = consumerBeforeComputation(node);\n            let newValue;\n            try {\n                const newSourceValue = node.source();\n                const prev = oldValue === UNSET || oldValue === ERRORED\n                    ? undefined\n                    : {\n                        source: node.sourceValue,\n                        value: oldValue,\n                    };\n                newValue = node.computation(newSourceValue, prev);\n                node.sourceValue = newSourceValue;\n            }\n            catch (err) {\n                newValue = ERRORED;\n                node.error = err;\n            }\n            finally {\n                consumerAfterComputation(node, prevConsumer);\n            }\n            if (oldValue !== UNSET && newValue !== ERRORED && node.equal(oldValue, newValue)) {\n                // No change to `valueVersion` - old and new values are\n                // semantically equivalent.\n                node.value = oldValue;\n                return;\n            }\n            node.value = newValue;\n            node.version++;\n        },\n    };\n})();\n\nfunction setAlternateWeakRefImpl(impl) {\n    // TODO: remove this function\n}\n\n/**\n * Execute an arbitrary function in a non-reactive (non-tracking) context. The executed function\n * can, optionally, return a value.\n */\nfunction untracked(nonReactiveReadsFn) {\n    const prevConsumer = setActiveConsumer(null);\n    // We are not trying to catch any particular errors here, just making sure that the consumers\n    // stack is restored in case of errors.\n    try {\n        return nonReactiveReadsFn();\n    }\n    finally {\n        setActiveConsumer(prevConsumer);\n    }\n}\n\nexport { signalUpdateFn as A, setAlternateWeakRefImpl as B, untracked as C, REACTIVE_NODE as R, SIGNAL as S, consumerDestroy as a, consumerPollProducersForChange as b, consumerMarkDirty as c, consumerBeforeComputation as d, consumerAfterComputation as e, createComputed as f, createLinkedSignal as g, linkedSignalUpdateFn as h, isInNotificationPhase as i, defaultEquals as j, getActiveConsumer as k, linkedSignalSetFn as l, isReactive as m, producerIncrementEpoch as n, producerMarkClean as o, producerAccessed as p, producerNotifyConsumers as q, producerUpdateValueVersion as r, setThrowInvalidWriteToSignalError as s, producerUpdatesAllowed as t, setActiveConsumer as u, SIGNAL_NODE as v, createSignal as w, runPostSignalSetFn as x, setPostSignalSetFn as y, signalSetFn as z };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}