{"ast":null,"code":"/**\n * @license Angular v19.2.4\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { c as consumerMarkDirty, S as SIGNAL, a as consumerDestroy, i as isInNotificationPhase, b as consumerPollProducersForChange, d as consumerBeforeComputation, e as consumerAfterComputation, R as REACTIVE_NODE } from '../untracked-CS7WUAzb.mjs';\nexport { v as SIGNAL_NODE, f as createComputed, g as createLinkedSignal, w as createSignal, j as defaultEquals, k as getActiveConsumer, m as isReactive, l as linkedSignalSetFn, h as linkedSignalUpdateFn, p as producerAccessed, n as producerIncrementEpoch, o as producerMarkClean, q as producerNotifyConsumers, r as producerUpdateValueVersion, t as producerUpdatesAllowed, x as runPostSignalSetFn, u as setActiveConsumer, B as setAlternateWeakRefImpl, y as setPostSignalSetFn, s as setThrowInvalidWriteToSignalError, z as signalSetFn, A as signalUpdateFn, C as untracked } from '../untracked-CS7WUAzb.mjs';\nfunction createWatch(fn, schedule, allowSignalWrites) {\n  const node = Object.create(WATCH_NODE);\n  if (allowSignalWrites) {\n    node.consumerAllowSignalWrites = true;\n  }\n  node.fn = fn;\n  node.schedule = schedule;\n  const registerOnCleanup = cleanupFn => {\n    node.cleanupFn = cleanupFn;\n  };\n  function isWatchNodeDestroyed(node) {\n    return node.fn === null && node.schedule === null;\n  }\n  function destroyWatchNode(node) {\n    if (!isWatchNodeDestroyed(node)) {\n      consumerDestroy(node); // disconnect watcher from the reactive graph\n      node.cleanupFn();\n      // nullify references to the integration functions to mark node as destroyed\n      node.fn = null;\n      node.schedule = null;\n      node.cleanupFn = NOOP_CLEANUP_FN;\n    }\n  }\n  const run = () => {\n    if (node.fn === null) {\n      // trying to run a destroyed watch is noop\n      return;\n    }\n    if (isInNotificationPhase()) {\n      throw new Error(`Schedulers cannot synchronously execute watches while scheduling.`);\n    }\n    node.dirty = false;\n    if (node.hasRun && !consumerPollProducersForChange(node)) {\n      return;\n    }\n    node.hasRun = true;\n    const prevConsumer = consumerBeforeComputation(node);\n    try {\n      node.cleanupFn();\n      node.cleanupFn = NOOP_CLEANUP_FN;\n      node.fn(registerOnCleanup);\n    } finally {\n      consumerAfterComputation(node, prevConsumer);\n    }\n  };\n  node.ref = {\n    notify: () => consumerMarkDirty(node),\n    run,\n    cleanup: () => node.cleanupFn(),\n    destroy: () => destroyWatchNode(node),\n    [SIGNAL]: node\n  };\n  return node.ref;\n}\nconst NOOP_CLEANUP_FN = () => {};\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst WATCH_NODE = /* @__PURE__ */(() => {\n  return {\n    ...REACTIVE_NODE,\n    consumerIsAlwaysLive: true,\n    consumerAllowSignalWrites: false,\n    consumerMarkedDirty: node => {\n      if (node.schedule !== null) {\n        node.schedule(node.ref);\n      }\n    },\n    hasRun: false,\n    cleanupFn: NOOP_CLEANUP_FN\n  };\n})();\nexport { REACTIVE_NODE, SIGNAL, consumerAfterComputation, consumerBeforeComputation, consumerDestroy, consumerMarkDirty, consumerPollProducersForChange, createWatch, isInNotificationPhase };","map":{"version":3,"names":["c","consumerMarkDirty","S","SIGNAL","a","consumerDestroy","i","isInNotificationPhase","b","consumerPollProducersForChange","d","consumerBeforeComputation","e","consumerAfterComputation","R","REACTIVE_NODE","v","SIGNAL_NODE","f","createComputed","g","createLinkedSignal","w","createSignal","j","defaultEquals","k","getActiveConsumer","m","isReactive","l","linkedSignalSetFn","h","linkedSignalUpdateFn","p","producerAccessed","n","producerIncrementEpoch","o","producerMarkClean","q","producerNotifyConsumers","r","producerUpdateValueVersion","t","producerUpdatesAllowed","x","runPostSignalSetFn","u","setActiveConsumer","B","setAlternateWeakRefImpl","y","setPostSignalSetFn","s","setThrowInvalidWriteToSignalError","z","signalSetFn","A","signalUpdateFn","C","untracked","createWatch","fn","schedule","allowSignalWrites","node","Object","create","WATCH_NODE","consumerAllowSignalWrites","registerOnCleanup","cleanupFn","isWatchNodeDestroyed","destroyWatchNode","NOOP_CLEANUP_FN","run","Error","dirty","hasRun","prevConsumer","ref","notify","cleanup","destroy","consumerIsAlwaysLive","consumerMarkedDirty"],"sources":["/home/xhani-manolis-trungu/angular-material2-portal-tools-poc/node_modules/@angular/core/fesm2022/primitives/signals.mjs"],"sourcesContent":["/**\n * @license Angular v19.2.4\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { c as consumerMarkDirty, S as SIGNAL, a as consumerDestroy, i as isInNotificationPhase, b as consumerPollProducersForChange, d as consumerBeforeComputation, e as consumerAfterComputation, R as REACTIVE_NODE } from '../untracked-CS7WUAzb.mjs';\nexport { v as SIGNAL_NODE, f as createComputed, g as createLinkedSignal, w as createSignal, j as defaultEquals, k as getActiveConsumer, m as isReactive, l as linkedSignalSetFn, h as linkedSignalUpdateFn, p as producerAccessed, n as producerIncrementEpoch, o as producerMarkClean, q as producerNotifyConsumers, r as producerUpdateValueVersion, t as producerUpdatesAllowed, x as runPostSignalSetFn, u as setActiveConsumer, B as setAlternateWeakRefImpl, y as setPostSignalSetFn, s as setThrowInvalidWriteToSignalError, z as signalSetFn, A as signalUpdateFn, C as untracked } from '../untracked-CS7WUAzb.mjs';\n\nfunction createWatch(fn, schedule, allowSignalWrites) {\n    const node = Object.create(WATCH_NODE);\n    if (allowSignalWrites) {\n        node.consumerAllowSignalWrites = true;\n    }\n    node.fn = fn;\n    node.schedule = schedule;\n    const registerOnCleanup = (cleanupFn) => {\n        node.cleanupFn = cleanupFn;\n    };\n    function isWatchNodeDestroyed(node) {\n        return node.fn === null && node.schedule === null;\n    }\n    function destroyWatchNode(node) {\n        if (!isWatchNodeDestroyed(node)) {\n            consumerDestroy(node); // disconnect watcher from the reactive graph\n            node.cleanupFn();\n            // nullify references to the integration functions to mark node as destroyed\n            node.fn = null;\n            node.schedule = null;\n            node.cleanupFn = NOOP_CLEANUP_FN;\n        }\n    }\n    const run = () => {\n        if (node.fn === null) {\n            // trying to run a destroyed watch is noop\n            return;\n        }\n        if (isInNotificationPhase()) {\n            throw new Error(`Schedulers cannot synchronously execute watches while scheduling.`);\n        }\n        node.dirty = false;\n        if (node.hasRun && !consumerPollProducersForChange(node)) {\n            return;\n        }\n        node.hasRun = true;\n        const prevConsumer = consumerBeforeComputation(node);\n        try {\n            node.cleanupFn();\n            node.cleanupFn = NOOP_CLEANUP_FN;\n            node.fn(registerOnCleanup);\n        }\n        finally {\n            consumerAfterComputation(node, prevConsumer);\n        }\n    };\n    node.ref = {\n        notify: () => consumerMarkDirty(node),\n        run,\n        cleanup: () => node.cleanupFn(),\n        destroy: () => destroyWatchNode(node),\n        [SIGNAL]: node,\n    };\n    return node.ref;\n}\nconst NOOP_CLEANUP_FN = () => { };\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\nconst WATCH_NODE = /* @__PURE__ */ (() => {\n    return {\n        ...REACTIVE_NODE,\n        consumerIsAlwaysLive: true,\n        consumerAllowSignalWrites: false,\n        consumerMarkedDirty: (node) => {\n            if (node.schedule !== null) {\n                node.schedule(node.ref);\n            }\n        },\n        hasRun: false,\n        cleanupFn: NOOP_CLEANUP_FN,\n    };\n})();\n\nexport { REACTIVE_NODE, SIGNAL, consumerAfterComputation, consumerBeforeComputation, consumerDestroy, consumerMarkDirty, consumerPollProducersForChange, createWatch, isInNotificationPhase };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}